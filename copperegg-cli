#!/usr/bin/env python
# -*- coding: utf-8 -*-

""" CopperEgg API CLI utility
"""

__author__ = "PÃ¥l Nilsen (@maedox)"
__version__ = "0.1"

import argparse
import json
import logging
import logging.handlers
from multiprocessing.dummy import Pool
from os import path
from sys import stdout

try:
    import copperegg
except ImportError:
    print("""python-copperegg is required for this script to work.\n"""
          """See https://github.com/maedox/python-copperegg""")

valid_frequencies = (15, 60, 300)

regions = {
    "us-east": {
        "atl": "Atlanta, GA (linode)",
        "dal": "Dallas, TX (linode)",
        "nrk": "Newark, NJ (linode)",
        "nva": "N. Virginia (aws)",
    },
    "us-west": {
        "fre": "Fremont, CA (linode)",
        "nca": "N. California (aws)",
        "ore": "Oregon (aws)",
    },
    "eu": {
        "amd": "Amsterdam, NL (softlayer)",
        "ire": "Dublin, IE (aws)",
        "lon": "London, UK (linode)"
    },
    "apac": {
        "sin": "Singapore (aws)",
        "syd": "Sydney, AU (aws)",
        "tky": "Tokyo, JP (aws)",
        "tok": "Tokyo, JP (linode)",
    },
    "s-am": {
        "sap": "Sao Paulo, BR (aws)",
    }
}
valid_regions = []
valid_stations = []
for k, v in regions.items():
    valid_regions.append(k)

    for s in v.keys():
        valid_stations.append(s)

ce_stations = list(valid_stations)
valid_stations.append("all")

log_path = path.join(path.expanduser("~"), ".copperegg-cli.log")
log_handler = logging.handlers.RotatingFileHandler(
    filename=log_path, maxBytes=1000000, backupCount=1, encoding="utf-8")
log_format = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
log_handler.setFormatter(log_format)

log_stdout = logging.StreamHandler(stdout)
log_stdout.setFormatter(log_format)

log = logging.getLogger(log_path)

valid_log_levels = ("CRITICAL", "ERROR", "WARNING", "INFO", "DEBUG", "NOTSET")
log.setLevel("INFO")
log.addHandler(log_handler)


class CopperEggCli(object):

    def __init__(self):
        self.api = copperegg.CopperEgg()

    def get_stations_from_region(self, region):
        """ Returns a list of all stations in a given region
        """
        output = []
        if region in valid_regions:
            for station in regions[region]:
                output.append(station)

        return output

    def get_stations(self, stations):
        """ Returns a list of valid stations

        Input can be any list of stations or regions.
        """
        stations = list(stations)
        region_stations = []

        if "all" in stations:
            return ce_stations

        else:
            output = []

            for station in stations:
                if station in valid_stations:
                    output.append(station)

                elif station in valid_regions:
                    region_stations = self.get_stations_from_region(station)

                if region_stations:
                    output.extend(region_stations)

            return list(set().union(output, region_stations))

    def process_probe(self, probe):
        """ Process probes and decide if data changes are necessary
        """
        data = {}

        if self.arg_set_stations:
            probe_stations = probe["stations"]

            if any(s not in probe_stations for s in self.arg_set_stations):
                if self.replace_stations:
                    data["stations"] = list(self.arg_set_stations)

                else:
                    data["stations"] = probe_stations
                    for station in self.arg_set_stations:
                        if station not in probe_stations:
                            data["stations"].append(station)

        if self.arg_set_frequency and \
                self.arg_set_frequency != probe["frequency"]:
            data["frequency"] = self.arg_set_frequency

        if self.arg_set_state and \
                self.arg_set_state != probe["state"]:
            data["state"] = self.arg_set_state

        if self.noop:
            log.debug("[NOOP] Current probe data:\n%s",
                      json.dumps(probe, indent=2))
            if data:
                log.debug("[NOOP] Data that would be changed:\n%s",
                          json.dumps(data, indent=2))
                log.info("""[NOOP] Would have updated "%s" (id: %s), """
                         """setting data: %s""",
                         probe["probe_desc"], probe["id"], data)

            else:
                log.info("[NOOP] No data to change.")

        else:
            if data:
                log.info("""Updating "%s" (id: %s), setting data: %s""",
                         probe["probe_desc"], probe["id"], data)
                return self.api.update_probe(probe["id"], data)
            else:
                log.info("""Matched probe "%s" (id: %s)""",
                         probe["probe_desc"], probe["id"])

    def main(self):
        parser = argparse.ArgumentParser(
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)

        # Search arguments
        parser.add_argument("--get-probes", nargs="+", default=[],
                            metavar="id", help="Probe id or all")
        parser.add_argument("--get-tags", nargs="+", default=[],
                            metavar="tag", help="Tag or all")

        # Data setting arguments
        parser.add_argument("--set-state", choices=("enabled", "disabled"),
                            default=None, help="Enable or disable a probe.")
        parser.add_argument("--set-frequency", type=int,
                            choices=valid_frequencies, metavar="frequency",
                            help="Seconds between tests.")
        parser.add_argument("--set-stations", nargs="+",
                            default=[], metavar="station",
                            choices=valid_stations + valid_regions,
                            help="Stations to enable.")

        # Action arguments
        parser.add_argument("--replace-stations", action="store_true",
                            help="Replace stations with supplied list.")
        parser.add_argument("--noop", action="store_true",
                            help="Do nothing, "
                                 "just show what would have been done.")

        # Help arguments
        parser.add_argument("--help-stations", action="store_true",
                            help="Show list of valid station identifiers.")

        # Output controlling arguments
        parser.add_argument("--log-level", default="INFO",
                            choices=valid_log_levels, help="Logging level.")
        parser.add_argument("--silent", action="store_true",
                            help="Stay silent and don't print actions to "
                                 "stdout. Logging will still occur.")

        args = parser.parse_args()

        log.setLevel(args.log_level)
        if not args.silent:
            log.addHandler(log_stdout)

        self.arg_get_probes = args.get_probes
        self.arg_get_tags = args.get_tags
        self.arg_set_frequency = args.set_frequency
        self.arg_set_stations = self.get_stations(args.set_stations)
        self.arg_set_state = args.set_state

        help_stations = args.help_stations
        self.replace_stations = args.replace_stations
        self.noop = args.noop

        if help_stations:
            print("Valid stations [region, id, location (provider)]:\n")
            print(json.dumps(regions, indent=2))
            print("\nYou may additionally use 'all' to enable all stations.")
            exit(0)

        if not self.arg_get_probes and not self.arg_get_tags:
            log.error("You have to specify at least one probe or tag.")
            parser.print_help()
            exit(2)

        if self.replace_stations and not self.arg_set_stations:
            log.error("--replace-stations requires --set-stations to be set.")
            parser.print_help()
            exit(3)

        elif self.replace_stations and len(self.arg_set_stations) < 3:
            if "all" not in self.arg_set_stations:
                log.error("Supply at least three stations when replacing.")
                exit(4)

        existing_probes = self.api.list_probes()
        if not existing_probes:
            log.info("No probes found.")
            exit(0)

        probes_to_process = []

        for probe in existing_probes:
            if "all" in self.arg_get_probes or "all" in self.arg_get_tags or \
                    probe["id"] in self.arg_get_probes or \
                    any(tag in self.arg_get_tags for tag in probe["tags"]):
                probes_to_process.append(probe)

        if probes_to_process:
            log.debug("Probes to process: %s", probes_to_process)

            pool = Pool(20)
            processing_result = pool.map(self.process_probe, probes_to_process)
            pool.close()
            pool.join()
            log.debug("Processing result: %s",
                      json.dumps(processing_result, indent=2))

        else:
            log.info("No matching probes found.")
            exit(0)


if __name__ == "__main__":
    cli = CopperEggCli()
    cli.main()
