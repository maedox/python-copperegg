#!/usr/bin/env python
# -*- coding: utf-8 -*-

""" CopperEgg API CLI utility
"""

__author__ = "PÃ¥l Nilsen (@maedox)"

import argparse
import json
import logging
import logging.handlers
import time
from multiprocessing.dummy import Pool
from os import path
from sys import stdout

try:
    import copperegg
except ImportError:
    print("""python-copperegg is required for this script to work.\n"""
          """See https://github.com/maedox/python-copperegg""")

valid_frequencies = (15, 60, 300)
valid_types = ("GET", "POST", "TCP", "ICMP")

regions = {
    "us-east": {
        "atl": "Atlanta, GA (linode)",
        "dal": "Dallas, TX (linode)",
        "nrk": "Newark, NJ (linode)",
        "nva": "N. Virginia (aws)",
    },
    "us-west": {
        "fre": "Fremont, CA (linode)",
        "nca": "N. California (aws)",
        "ore": "Oregon (aws)",
    },
    "eu": {
        "amd": "Amsterdam, NL (softlayer)",
        "ire": "Dublin, IE (aws)",
        "lon": "London, UK (linode)"
    },
    "apac": {
        "sin": "Singapore (aws)",
        "syd": "Sydney, AU (aws)",
        "tky": "Tokyo, JP (aws)",
        "tok": "Tokyo, JP (linode)",
    },
    "s-am": {
        "sap": "Sao Paulo, BR (aws)",
    }
}
valid_regions = []
valid_stations = []
for k, v in regions.items():
    valid_regions.append(k)

    for s in v.keys():
        valid_stations.append(s)

ce_stations = list(valid_stations)
valid_stations.append("all")

log_path = path.join(path.expanduser("~"), ".copperegg-cli.log")
log_handler = logging.handlers.RotatingFileHandler(
    filename=log_path, maxBytes=1000000, backupCount=1, encoding="utf-8")
log_format = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
log_handler.setFormatter(log_format)

log_stdout = logging.StreamHandler(stdout)
log_stdout.setFormatter(log_format)

log = logging.getLogger(log_path)

valid_log_levels = ("CRITICAL", "ERROR", "WARNING", "INFO", "DEBUG", "NOTSET")
log.setLevel("INFO")
log.addHandler(log_handler)


class CopperEggCli(object):

    def __init__(self):
        self.api = copperegg.CopperEgg()

    def check_arguments(self):
        log.setLevel(self.args.log_level)
        if not self.args.silent:
            log.addHandler(log_stdout)

        if self.args.help_stations:
            print("Valid stations [region, id, location (provider)]:\n")
            print(json.dumps(regions, indent=2))
            print("\nYou may additionally use 'all' to enable all stations.")
            exit(0)

        if not self.args.add and not self.args.get_probes and not self.args.get_tags:
            log.error("You have to specify at least one probe or tag.")
            exit(2)

        if self.args.replace_stations and not self.args.set_stations:
            log.error("--replace-stations requires --set-stations to be set.")
            exit(3)

        elif self.args.replace_stations and len(self.args.set_stations) < 3:
            if "all" not in self.args.set_stations:
                log.error("Supply at least three stations when replacing.")
                exit(4)

        if self.args.add:
            if not self.args.set_desc or not self.args.set_dest or not \
                    self.args.set_type:
                log.error("--set-desc, --set-dest and --set-type are all "
                          "required when adding a probe.")
                exit(5)

    def convert_unix_time(self, timestamp):
        """ Converts seconds since epoch into 'yyyy-mm-dd hh:mm:ss tzname' """
        return time.strftime("%F %T %Z", time.localtime(int(timestamp)))

    def get_stations_from_region(self, region):
        """ Returns a list of all stations in a given region
        """
        output = []
        if region in valid_regions:
            for station in regions[region]:
                output.append(station)

        return output

    def get_stations(self, stations):
        """ Returns a list of valid stations

        Input can be any list of stations or regions.
        """
        stations = list(stations)
        region_stations = []

        if "all" in stations:
            return ce_stations

        else:
            output = []

            for station in stations:
                if station in valid_stations:
                    output.append(station)

                elif station in valid_regions:
                    region_stations = self.get_stations_from_region(station)

                if region_stations:
                    output.extend(region_stations)

            return list(set().union(output, region_stations))

    def print_noop_text(self, probe, data):
        if not self.args.add:
            log.debug("[NOOP] Current probe data:\n%s",
                      json.dumps(probe, indent=2))

        if data:
            if self.args.add:
                log.info("""[NOOP] Would have added "%s", data: %s""",
                         self.args.set_desc, json.dumps(data, indent=2))

            else:
                log.debug("[NOOP] Data that would be changed:\n%s",
                          json.dumps(data, indent=2))
                log.info("""[NOOP] Would have updated "%s" (id: %s), """
                         """setting data: %s""",
                         probe["probe_desc"], probe["id"],
                         json.dumps(data, indent=2))

        elif self.args.delete:
            log.info("""[NOOP] Would have deleted "%s" (id: %s), data: %s""",
                     probe["probe_desc"], probe["id"],
                     json.dumps(probe, indent=2))

        else:
            log.info("""[NOOP] Probe "%s" (id: %s): No changes.""",
                     probe["probe_desc"], probe["id"])

    def update_probe(self, probe, data):
        if self.args.add:
            log.info("""Adding "%s", data: %s""",
                     self.args.set_desc, json.dumps(data, indent=2))
            new_probe = self.api.add_probe(data)
            log.info("Added new probe: %s",
                     json.dumps(new_probe, indent=2))
            return True

        else:
            if len(self.probes_to_process) > 1 and not self.args.force and \
                    "probe_desc" in data or "probe_dest" in data:
                log.warning("If you want to set probe_desc and/or "
                            "probe_dest on multiple probes you have to "
                            "add the --force argument.")

            log.info("""Updating "%s" (id: %s), setting data: %s""",
                     probe["probe_desc"], probe["id"], data)
            return self.api.update_probe(probe["id"], data)

    def delete_probe(self, probe):
        log.info("""Deleting "%s", data: %s""",
                 probe["probe_desc"], json.dumps(probe, indent=2))
        self.api.delete_probe(probe["id"])
        return True

    def process_probe(self, probe):
        """ Process probes and decide if data changes are necessary
        """
        data = {}

        if not self.args.delete:
            if self.args.add:
                if any(self.args.set_dest in p["probe_dest"]
                        for p in self.existing_probes) and not self.args.force:
                    log.error("""Probe with URL "%s" already exists. """
                              "Add the --force argument to add it anyway.",
                              self.args.set_dest)
                    exit(1)

                data["probe_desc"] = self.args.set_desc
                data["probe_dest"] = self.args.set_dest
                data["type"] = self.args.set_type

                if self.args.set_frequency:
                    data["frequency"] = self.args.set_frequency

                if self.args.set_stations:
                    data["stations"] = self.args.set_stations

                if self.args.set_tags:
                    data["tags"] = self.args.set_tags

            else:
                if self.args.set_state and \
                        self.args.set_state != probe["state"]:
                    data["state"] = self.args.set_state

                if len(self.probes_to_process) == 1 or self.args.force:
                    if self.args.set_desc and \
                            self.args.set_desc != probe["probe_desc"]:
                        data["probe_desc"] = self.args.set_desc

                    if self.args.set_dest and \
                            self.args.set_dest != probe["probe_dest"]:
                        data["probe_dest"] = self.args.set_dest

                if self.args.set_type and \
                        self.args.set_type != probe["type"]:
                    data["type"] = self.args.set_type

                if self.args.set_frequency and \
                        self.args.set_frequency != probe["frequency"]:
                    data["frequency"] = self.args.set_frequency

                if self.args.set_stations:
                    old = sorted(probe["stations"])
                    new = sorted(self.args.set_stations)
                    if old != new:
                        if self.args.replace_stations:
                            data["stations"] = new

                        elif any(True for field in new if field not in old):
                            output = old
                            for field in new:
                                if field not in old:
                                    output.append(field)
                            data["stations"] = output

                if self.args.set_tags:
                    old = sorted(probe["tags"])
                    new = sorted(self.args.set_tags)
                    if old != new:
                        if self.args.replace_tags:
                            data["tags"] = new

                        elif any(True for field in new if field not in old):
                            output = old
                            for field in new:
                                if field not in old:
                                    output.append(field)
                            data["tags"] = output

        if self.args.noop:
            return self.print_noop_text(probe, data)

        else:
            if self.args.delete:
                return self.delete_probe(probe)

            if data:
                return self.update_probe(probe, data)

            else:
                log.info("No changes: %s (id: %s, created: %s, updated: %s): "
                         "Check: %s %s, Interval: %d s, Stations: [%s], "
                         "Tags: [%s]", probe["probe_desc"], probe["id"],
                         self.convert_unix_time(probe["created_at"]),
                         self.convert_unix_time(probe["updated_at"]),
                         probe["type"], probe["probe_dest"], probe["frequency"],
                         ", ".join(probe["stations"]), ", ".join(probe["tags"]))

    def main(self):
        parser = argparse.ArgumentParser(
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)

        # Search arguments
        parser.add_argument("--get-probes", nargs="+", default=[],
                            metavar="id", help="Probe id or all")
        parser.add_argument("--get-tags", nargs="+", default=[],
                            metavar="tag", help="Tag or all")

        # Data setting arguments
        parser.add_argument("--set-state", choices=("enabled", "disabled"),
                            default=None, help="Enable or disable a probe.")
        parser.add_argument("--set-desc",
                            help="Probe description or name.")
        parser.add_argument("--set-frequency", type=int,
                            choices=valid_frequencies, metavar="frequency",
                            help="Seconds between tests.")
        parser.add_argument("--set-type", choices=valid_types,
                            help="Type of probe.")
        parser.add_argument("--set-dest",
                            help="Destination URL for the probe.")
        parser.add_argument("--set-stations", nargs="+", default=[],
                            choices=valid_stations + valid_regions,
                            help="Stations to enable.")
        parser.add_argument("--set-tags", nargs="+", default=[],
                            help="Tags to set.")

        # Action arguments
        group = parser.add_mutually_exclusive_group()
        group.add_argument("--add", action="store_true",
                           help="Add a probe.")
        group.add_argument("--delete", action="store_true",
                           help="Delete one or more probes.")

        parser.add_argument("--replace-stations", action="store_true",
                            help="Replace stations with supplied list.")
        parser.add_argument("--replace-tags", action="store_true",
                            help="Replace tags with supplied list.")
        parser.add_argument("--noop", action="store_true",
                            help="Do nothing, "
                                 "just show what would have been done.")
        parser.add_argument("--force", action="store_true",
                            help="Override add/delete restrictions.")

        # Help arguments
        parser.add_argument("--help-stations", action="store_true",
                            help="Show list of valid station identifiers.")

        # Output controlling arguments
        parser.add_argument("--log-level", default="INFO",
                            choices=valid_log_levels, help="Logging level.")
        parser.add_argument("--silent", action="store_true",
                            help="Stay silent and don't print actions to "
                                 "stdout. Logging will still occur.")

        self.args = parser.parse_args()
        self.args.set_stations = self.get_stations(self.args.set_stations)

        self.check_arguments()

        self.existing_probes = self.api.list_probes() or []
        self.probes_to_process = []

        if self.args.add:
            self.probes_to_process = [{"probe_desc": self.args.set_desc}]

        else:
            for probe in self.existing_probes:
                if "all" in self.args.get_probes or "all" in self.args.get_tags or \
                        probe["id"] in self.args.get_probes or \
                        any(tag in self.args.get_tags for tag in probe["tags"]):
                    self.probes_to_process.append(probe)

        if self.probes_to_process:
            if self.args.add:
                self.process_probe(self.probes_to_process)

            elif self.args.delete and not self.args.force and \
                    len(self.probes_to_process) > 5:
                log.error("If you really want to delete %s probes, you need "
                          "to supply the --force argument.",
                          len(self.probes_to_process))
                exit(1)

            else:
                log.debug("Probes to process: %s",
                          json.dumps(self.probes_to_process, indent=2))

                pool = Pool(20)
                processing_result = pool.map(
                    self.process_probe, self.probes_to_process
                )
                pool.close()
                pool.join()
                log.debug("Processing result: %s",
                          json.dumps(processing_result, indent=2))

        else:
            log.info("No matching probes found.")
            exit(0)


if __name__ == "__main__":
    cli = CopperEggCli()
    cli.main()
