#!/usr/bin/env python
# -*- coding: utf-8 -*-

""" CopperEgg API CLI utility
"""

__author__ = "PÃ¥l Nilsen (@maedox)"

import argparse
import json
import logging
import logging.handlers
from multiprocessing.dummy import Pool
from os import path
from sys import stdout

try:
    import copperegg
except ImportError:
    print("""python-copperegg is required for this script to work.\n"""
          """See https://github.com/maedox/python-copperegg""")

valid_frequencies = (15, 60, 300)
valid_types = ("GET", "POST", "TCP", "ICMP")

regions = {
    "us-east": {
        "atl": "Atlanta, GA (linode)",
        "dal": "Dallas, TX (linode)",
        "nrk": "Newark, NJ (linode)",
        "nva": "N. Virginia (aws)",
    },
    "us-west": {
        "fre": "Fremont, CA (linode)",
        "nca": "N. California (aws)",
        "ore": "Oregon (aws)",
    },
    "eu": {
        "amd": "Amsterdam, NL (softlayer)",
        "ire": "Dublin, IE (aws)",
        "lon": "London, UK (linode)"
    },
    "apac": {
        "sin": "Singapore (aws)",
        "syd": "Sydney, AU (aws)",
        "tky": "Tokyo, JP (aws)",
        "tok": "Tokyo, JP (linode)",
    },
    "s-am": {
        "sap": "Sao Paulo, BR (aws)",
    }
}
valid_regions = []
valid_stations = []
for k, v in regions.items():
    valid_regions.append(k)

    for s in v.keys():
        valid_stations.append(s)

ce_stations = list(valid_stations)
valid_stations.append("all")

log_path = path.join(path.expanduser("~"), ".copperegg-cli.log")
log_handler = logging.handlers.RotatingFileHandler(
    filename=log_path, maxBytes=1000000, backupCount=1, encoding="utf-8")
log_format = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
log_handler.setFormatter(log_format)

log_stdout = logging.StreamHandler(stdout)
log_stdout.setFormatter(log_format)

log = logging.getLogger(log_path)

valid_log_levels = ("CRITICAL", "ERROR", "WARNING", "INFO", "DEBUG", "NOTSET")
log.setLevel("INFO")
log.addHandler(log_handler)


class CopperEggCli(object):

    def __init__(self):
        self.api = copperegg.CopperEgg()

    def get_stations_from_region(self, region):
        """ Returns a list of all stations in a given region
        """
        output = []
        if region in valid_regions:
            for station in regions[region]:
                output.append(station)

        return output

    def get_stations(self, stations):
        """ Returns a list of valid stations

        Input can be any list of stations or regions.
        """
        stations = list(stations)
        region_stations = []

        if "all" in stations:
            return ce_stations

        else:
            output = []

            for station in stations:
                if station in valid_stations:
                    output.append(station)

                elif station in valid_regions:
                    region_stations = self.get_stations_from_region(station)

                if region_stations:
                    output.extend(region_stations)

            return list(set().union(output, region_stations))

    def process_probe(self, probe):
        """ Process probes and decide if data changes are necessary
        """
        data = {}

        if not self.delete:
            if self.add:
                if any(self.arg_set_dest in p["probe_dest"]
                        for p in self.existing_probes) and not self.force:
                    log.error("""Probe with URL "%s" already exists. """
                              "Add the --force argument to add it anyway.",
                              self.arg_set_dest)
                    exit(1)

                data["probe_desc"] = self.arg_set_desc
                data["probe_dest"] = self.arg_set_dest
                data["type"] = self.arg_set_type

                if self.arg_set_frequency:
                    data["frequency"] = self.arg_set_frequency

                if self.arg_set_stations:
                    data["stations"] = self.arg_set_stations

                if self.arg_set_tags:
                    data["tags"] = self.arg_set_tags

            else:
                if self.arg_set_state and \
                        self.arg_set_state != probe["state"]:
                    data["state"] = self.arg_set_state

                if len(self.probes_to_process) == 1 or self.force:
                    if self.arg_set_desc and \
                            self.arg_set_desc != probe["probe_desc"]:
                        data["probe_desc"] = self.arg_set_desc

                    if self.arg_set_dest and \
                            self.arg_set_dest != probe["probe_dest"]:
                        data["probe_dest"] = self.arg_set_dest

                if self.arg_set_type and \
                        self.arg_set_type != probe["type"]:
                    data["type"] = self.arg_set_type

                if self.arg_set_frequency and \
                        self.arg_set_frequency != probe["frequency"]:
                    data["frequency"] = self.arg_set_frequency

                if self.arg_set_stations:
                    old = sorted(probe["stations"])
                    new = sorted(self.arg_set_stations)
                    if old != new:
                        if self.replace_stations:
                            data["stations"] = new

                        elif any(True for field in new if field not in old):
                            output = old
                            for field in new:
                                if field not in old:
                                    output.append(field)
                            data["stations"] = output

                if self.arg_set_tags:
                    old = sorted(probe["tags"])
                    new = sorted(self.arg_set_tags)
                    if old != new:
                        if self.replace_tags:
                            data["tags"] = new

                        elif any(True for field in new if field not in old):
                            output = old
                            for field in new:
                                if field not in old:
                                    output.append(field)
                            data["tags"] = output

        if self.noop:
            if not self.add:
                log.debug("[NOOP] Current probe data:\n%s",
                          json.dumps(probe, indent=2))

            if data:
                if self.add:
                    log.info("""[NOOP] Would have added "%s", data: %s""",
                             self.arg_set_desc, json.dumps(data, indent=2))

                else:
                    log.debug("[NOOP] Data that would be changed:\n%s",
                              json.dumps(data, indent=2))
                    log.info("""[NOOP] Would have updated "%s" (id: %s), """
                             """setting data: %s""",
                             probe["probe_desc"], probe["id"],
                             json.dumps(data, indent=2))

            elif self.delete:
                log.info("""[NOOP] Would have deleted "%s" (id: %s), data: %s""",
                         probe["probe_desc"], probe["id"],
                         json.dumps(probe, indent=2))

            else:
                log.info("""[NOOP] Probe "%s" (id: %s): No changes.""",
                         probe["probe_desc"], probe["id"])

        else:
            if data:
                if self.add:
                    log.info("""Adding "%s", data: %s""",
                             self.arg_set_desc, json.dumps(data, indent=2))
                    new_probe = self.api.add_probe(data)
                    log.info("Added new probe: %s",
                             json.dumps(new_probe, indent=2))

                else:
                    if len(self.probes_to_process) > 1 and not self.force and \
                            "probe_desc" in probe or "probe_dest" in probe:
                        log.warning("If you want to set probe_desc and/or "
                                    "probe_dest on multiple probes you have to "
                                    "add the --force argument.")

                    log.info("""Updating "%s" (id: %s), setting data: %s""",
                             probe["probe_desc"], probe["id"], data)
                    return self.api.update_probe(probe["id"], data)

            elif self.delete:
                log.info("""Deleting "%s", data: %s""",
                         probe["probe_desc"], json.dumps(probe, indent=2))
                return self.api.delete_probe(probe["id"])

            else:
                log.info("""Matched probe "%s" (id: %s)""",
                         probe["probe_desc"], probe["id"])

    def main(self):
        parser = argparse.ArgumentParser(
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)

        # Search arguments
        parser.add_argument("--get-probes", nargs="+", default=[],
                            metavar="id", help="Probe id or all")
        parser.add_argument("--get-tags", nargs="+", default=[],
                            metavar="tag", help="Tag or all")

        # Data setting arguments
        parser.add_argument("--set-state", choices=("enabled", "disabled"),
                            default=None, help="Enable or disable a probe.")
        parser.add_argument("--set-desc",
                            help="Probe description or name.")
        parser.add_argument("--set-frequency", type=int,
                            choices=valid_frequencies, metavar="frequency",
                            help="Seconds between tests.")
        parser.add_argument("--set-type", choices=valid_types,
                            help="Type of probe.")
        parser.add_argument("--set-dest",
                            help="Destination URL for the probe.")
        parser.add_argument("--set-stations", nargs="+", default=[],
                            choices=valid_stations + valid_regions,
                            help="Stations to enable.")
        parser.add_argument("--set-tags", nargs="+", default=[],
                            help="Tags to set.")

        # Action arguments
        group = parser.add_mutually_exclusive_group()
        group.add_argument("--add", action="store_true",
                           help="Add a probe.")
        group.add_argument("--delete", action="store_true",
                           help="Delete one or more probes.")

        parser.add_argument("--replace-stations", action="store_true",
                            help="Replace stations with supplied list.")
        parser.add_argument("--replace-tags", action="store_true",
                            help="Replace tags with supplied list.")
        parser.add_argument("--noop", action="store_true",
                            help="Do nothing, "
                                 "just show what would have been done.")
        parser.add_argument("--force", action="store_true",
                            help="Override add/delete restrictions.")

        # Help arguments
        parser.add_argument("--help-stations", action="store_true",
                            help="Show list of valid station identifiers.")

        # Output controlling arguments
        parser.add_argument("--log-level", default="INFO",
                            choices=valid_log_levels, help="Logging level.")
        parser.add_argument("--silent", action="store_true",
                            help="Stay silent and don't print actions to "
                                 "stdout. Logging will still occur.")

        args = parser.parse_args()

        # Search arguments
        self.arg_get_probes = args.get_probes
        self.arg_get_tags = args.get_tags

        # Data setting arguments
        self.arg_set_desc = args.set_desc
        self.arg_set_frequency = args.set_frequency
        self.arg_set_type = args.set_type
        self.arg_set_dest = args.set_dest
        self.arg_set_stations = self.get_stations(args.set_stations)
        self.arg_set_tags = args.set_tags
        self.arg_set_state = args.set_state

        # Action arguments
        self.add = args.add
        self.delete = args.delete

        self.noop = args.noop
        self.force = args.force
        self.replace_tags = args.replace_tags
        self.replace_stations = args.replace_stations

        # Help arguments
        help_stations = args.help_stations

        # Output controlling arguments
        log.setLevel(args.log_level)
        if not args.silent:
            log.addHandler(log_stdout)

        if help_stations:
            print("Valid stations [region, id, location (provider)]:\n")
            print(json.dumps(regions, indent=2))
            print("\nYou may additionally use 'all' to enable all stations.")
            exit(0)

        if not self.add and not self.arg_get_probes and not self.arg_get_tags:
            log.error("You have to specify at least one probe or tag.")
            parser.print_help()
            exit(2)

        if self.replace_stations and not self.arg_set_stations:
            log.error("--replace-stations requires --set-stations to be set.")
            parser.print_help()
            exit(3)

        elif self.replace_stations and len(self.arg_set_stations) < 3:
            if "all" not in self.arg_set_stations:
                log.error("Supply at least three stations when replacing.")
                exit(4)

        if self.add:
            if not self.arg_set_desc or not self.arg_set_dest or not \
                    self.arg_set_type:
                log.error("--set-desc, --set-dest and --set-type are all "
                          "required when adding a probe.")
                exit(5)

        self.existing_probes = self.api.list_probes() or []
        self.probes_to_process = []

        if self.add:
            self.probes_to_process = [{"probe_desc": self.arg_set_desc}]

        else:
            for probe in self.existing_probes:
                if "all" in self.arg_get_probes or "all" in self.arg_get_tags or \
                        probe["id"] in self.arg_get_probes or \
                        any(tag in self.arg_get_tags for tag in probe["tags"]):
                    self.probes_to_process.append(probe)

        if self.probes_to_process:
            if self.add:
                self.process_probe(self.probes_to_process)

            elif self.delete and not self.force and \
                    len(self.probes_to_process) > 5:
                log.error("If you really want to delete %s probes, you need "
                          "to supply the --force argument.",
                          len(self.probes_to_process))
                exit(1)

            else:
                log.debug("Probes to process: %s",
                          json.dumps(self.probes_to_process, indent=2))

                pool = Pool(20)
                processing_result = pool.map(
                    self.process_probe, self.probes_to_process
                )
                pool.close()
                pool.join()
                log.debug("Processing result: %s",
                          json.dumps(processing_result, indent=2))

        else:
            log.info("No matching probes found.")
            exit(0)


if __name__ == "__main__":
    cli = CopperEggCli()
    cli.main()
